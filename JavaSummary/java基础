1.java语言特点
面向对象 （封装、继承、多态）简单 易学 可靠性 安全性 支持多线程

2.面向对象和面向过程的区别
面向过程性能较高，但是没有面向对象易维护、易复用、易扩展
面向对象易维护、易复用、易扩展，可以做出耦合性低的系统，但是性能相对来说较低

3.jvm jdk jre
java虚拟机 jvm可以理解的代码叫做字节码（扩展名.class）
.java文件（源代码）->（JDK中javac编译）.class文件（JVM可以理解的java字节码）->机器可以执行的二进制机器码
jdk：java development kit
jre:java运行时环境，运行已编译java程序所需要所有内容的集合

4.oraclejdk和openjdk对比

5.java和c++的异同？
都是面向对象的语言，支持封装、继承、多态
java不提供指针来直接访问内存，程序内存更加安全
java都是单继承的，c++支持多继承。java类不可以多继承但是接口可以多继承
java有自动内存管理机制，不用程序员手动释放内存

6.java的主类是什么？ 应用程序和小程序的主类有何不同？
一个程序可以有多个类，但是只能有一个主类。
主类是包含main()方法的类，在java小程序中，这个主类是继承自系统JApplet和Applet的子类，
应用程序的主类不一定要求是public，但是小程序的主类要求必须是public

7.java应用程序和小程序之间的差别
应用程序是main（）启动，applet小程序没有main()方法，主要是嵌在浏览器页面上运行，嵌入浏览器这点跟flash小程序类似

8.字符型常量和字符串常量的区别
字符型常量是单引号引起的一个字符，字符串常量是双引号引起来的若干个字符
字符型常量相当于一个整数值，字符串常量代表一个地址值
占内存大小 字符常量只占2个字节；字符串常量占若干个字节

9.java基本数据类型：
boolean char byte short int long float double void
boolean char byte short int long float double void

10.构造器可否被override？
构造器不能被override，但是可以overload，所以，所以一个类中可以有多个构造函数

11.重写和重载的区别？
（1）重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
重写就是子类继承自父类的相同方法，输入数据一样，但是要做出有别于父类的响应时，就要覆盖父类方法

重载发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同
（重载是对同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）

（2）重写发生在运行期，是子类对父类的允许访问的方法实现过程进行重新编写
返回值类型，方法名，参数列表必须相同，抛出异常范围小于等于父类，访问修饰符范围大于等于父类
父类方法修饰符为private/final/static 则子类就不能重写该方法，但是static修饰的方法能够被再次声明
构造方法无法被重写
（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）

12.聊聊封装、继承、多态
（1）封装：把一个对象的属性私有化，同时提供可以被外界访问的属性和方法，如果属性不想被外界访问，则不用提供方法给外界访问
（2）继承：使用已经存在的类的定义作为基础建立新的技术，新类的定义可以增加新的数据或者新的功能，也可以使用父类的功能，
但是不能选择性地继承父类，方便复用以前的代码。
（3）多态：程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，
而是在程序运行期间确定。一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法
必须由程序运行期间确定。
实现多态：（1）继承 多个子类对同一个方法的重写（2）接口：实现接口并覆盖接口中的同一个方法

13.StringBuffer 和StringBUilder区别
StringBuffer 和StringBUilder都继承自AbstractStringBuilder类，但是没用final关键字修饰，它们俩都是可变的
String 中对象不是可变的，可以理解为常量、线程安全；StringBuilder没有对方法加锁，线程不安全；StringBuffer对方法加了
同步锁或者对调用的方法加了同步锁，所以是线程安全的。
少量数据：用String
单线程操作字符串缓冲区下操作大量数据：StringBuilder
多线程操作字符串缓冲区下大量数据：StringBuffer


14.自动拆装箱
装箱：将基本数据用引用数据类型包装起来
拆箱：将包装数据类型转换为基本数据类型

15.在静态方法中调用一个非静态成员变量为什么是非法的？
静态方法可以不通过对象进行调用，在静态方法里不能调用其他非静态变量，也不可以访问非静态变量成员

16.import java和javax有什么区别


17.抽象类和接口的区别是什么
接口的方法默认是public，方法不能在接口里有实现、
接口中除了static final变量不能有其他变量，抽象类中不一定
一个类可以实现多个接口，但是之类实现一个抽象类，接口自己本身可以通过extends关键字扩展多个接口
接口方法默认修饰符是public，抽象方法可以有public protected 和default这些修饰符
从设计层面来说，抽象是对类的抽象，是一种模版设计、接口是对行为的抽象，是一个行为规范

18.成员变量和局部变量的区别
成员变量属于类，局部变量是在方法中定义的变量或者是方法的参数，成员变量可以被public static private等修饰符修饰，
局部变量不能访问控制修饰符及static修饰，但是成员变量和局部变量都能被final修饰
从变量在内存中的存储方式来看，成员变量是使用static修饰的，那么这个成员变量属于类，如果没有static修饰，这个
成员变量属于实例。对象存于堆内存，如果局部变量为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是
指向堆内存对象的引用或者是指向常量池中的地址。
从变量在内存中的生存时间看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法调用而自动消失。
成员变量没有被赋初值则会自动以类型的默认值赋值，而局部变量不会自动赋值。

19.创建一个对象用new 运算符
new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）

20.方法的返回值？获取方法体中的代码执行产生的结果

21.类的构造方法的作用？
对类对象初始化，可以执行。

22.构造方法有哪些特性
名字与类名相同，没有返回值且不能用void声明 生成类的对象自动执行，无需调用

23.静态方法与实例方法的差异
外部调用静态方法可以使用类名.方法名，也可以使用对象名.方法名的方式
实例方法只有后面这种方式，静态方法的调用无需创建对象
静态方法在访问本类的成员时，只允许访问静态成员（静态变量和静态方法）不允许访问实例成员变量和实例方法，实例方法没有此限制

24.对象相当和指向他们的引用相等，两者有什么不同？
对象相等比较的是内存中存放的值；而引用相等比较的是他们指向的内存地址是否相同

25.== 与equals
==判断的是两个对象的地址是不是相同，即两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型比较的是内存地址）
equals（）一般有两种使用情况：
类没有覆盖equals方法，此时等价于==来比较这两个对象
类覆盖了equals方法：若内容相等返回true

26.hashcode和equals
为什么重写equals时必须重写hashcode
hashcode 获取哈希码，返回一个int整数，这作用是确定该对象在哈希表中的索引位置。
当把对象加入hashset时，hashset会先计算对象的hashcode值来判断对象加入的位置，同时也会与该位置其他
已经加入的对象的hashcode值作比较。如果没有相符的hashcode，hashset会假设对象没有重复出现。但是如果发现有相同hashcode值
的对象，会调用equals（）方法来检查hashcode相等的对象是否真的相同。相同的话hashset就不会让其加入操作成功；如果不同的话就会重新
散列到其他位置。
如果两个对象相等，hashcode一定是相同的；
两个对象相等，对它们调用equals一定是相等的；
但是如果两个对象hashcode值相等，它们也不一定是相等的；
因此equals方法被覆盖过，hashcode方法一定也必须被覆盖

27.java为啥只有值传递


28.线程、进程、程序的基本概念 以及之间的关系
线程是比进程更小的执行单位，一个进程其中可以有很多的线程。与进程不同的是，同类中多个线程共享同一块内存空间和一组系统资源，
所以系统在产生或者在各个线程之间切换的时候，负担相较于进程小得多。
进程是程序运行的基本单位，进程是动态的。系统运行一个程序是一个进程从创建、运行到消亡的全过程。一个进程就是执行中的程序，同时
每个进程还占用某些系统资源如CPU时间、内存空间、文件，输入输出设备使用权等等。最大不同是进程之间是独立的，而线程不一定，同一进程中的线程
有可能相互影响。进程属于操作系统范畴，同一时间段内可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

29.线程的基本状态  6种
NEW RUNNABLE BLOCKED WAITING TIME_WAITING TERMINATED


30.final关键字的总结
final关键字主要用在三个地方：变量、方法、类
对于基本数据类型，数值一旦初始化后便不能再更改
用final修饰一个类的时候，表明这个类不能被继承，final类中所有的方法会隐式地指定为final方法
使用final的原因：1.把方法锁住，以防止任何继承类修改它的含义；
2.效率，在java早期的实现版本张，会将final方法转为内嵌调用，但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升

31.java中的异常处理
Throwable :1.Error               2.Exception
1.Error  程序有问题，故障发生在虚拟机自身、或者发生在虚拟机试图执行应用的时候，如虚拟机运行错误、类定义错误等。
2.Exception 程序本身可以处理的异常   RuntimeException(可以由java虚拟机抛出) NullPointerException(要访问的变量没有任何引用对象时，抛出该异常)
ArithmeticException（算术运算异常） ArrayIndexOutOfBoundsException（下标越界异常）
try{

}catch{

}finally{

}
如果finally和try语句中都有return时，在方法返回之前，finally语句的内容会被执行，并且finally语句的返回值会覆盖原始的返回值

32.java序列化中如果有字段不想进行序列化怎么办
不想进行序列化的变量使用transient关键字修饰


33.键盘输入
1.Scanner
Scanner sc = new Scanner(System.in)
String s = sc.nextLine();

2.BufferReader
BufferReader input = new BufferReader(new InputStreamReader(System.in))

34.Java中的IO流
按照流的流向：输入流、输出流
按照操作单元划分：字节流、字符流
流的角色划分：节点流、处理流

35.常见关键字总结 static、final、this、super

36.Collections工具类和Arrays工具类常见方法总结
1.Collections:
https://blog.csdn.net/weixin_39940206/article/details/93133923
void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。


int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素


synchronizedCollection(Collection<T>  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List<T> list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map<K,V> m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set<T> s) //返回指定 set 支持的同步（线程安全的）set。
emptyXxx(): 返回一个空的、不可变的集合对象，此处的集合既可以是List，也可以是Set，还可以是Map。
singletonXxx(): 返回一个只包含指定对象（只有一个或一个元素）的不可变的集合对象，此处的集合可以是：List，Set，Map。
unmodifiableXxx(): 返回指定集合对象的不可变视图，此处的集合可以是：List，Set，Map。
上面三类方法的参数是原有的集合对象，返回值是该集合的”只读“版本。

2.Arrays
排序sort();
查找binarySearch（）
比较equals()
填充fill()
转列表 asList()
转字符串 toString()
复制copyOf()


37.深拷贝和浅拷贝
深拷贝：对基本数据类型进行值传递，对引用数据类型创建一个新的对象，并复制其内容
浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝


一。数据类型
（1）基本类型
byte 8
char 16
short 16
int 32
float 32
long 64
double  64
boolean

（2）包装类型
基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()


（3）缓存池
new Integer(123) 与 Integer.valueOf(123) 的区别在于：
new Integer(123) 每次都会新建一个对象；
Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。

二。String
1.被声明为final 不可以被继承
(Integer 等包装类也不能被继承）
String不可变性的好处:(1)线程安全 （2）具有安全性 （3）可以缓存hash （4）String Pool的需要
2.String StringBuffer StringBuilder的区别
（1）可变性
String 不可变
StringBuffer 和 StringBuilder 可变
（2）线程安全性
String 不可变，因此是线程安全的
StringBuilder 不是线程安全的
StringBuffer 是线程安全的，内部使用 synchronized 进行同步



三。运算
1.参数传递
Java 的参数是以值传递的形式传入方法中，而不是引用传递。
在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。
在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。
但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。
2.float和double
隐式类型转换
3.switch


四。关键字
1.final
（1）数据
声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。
对于基本类型，final 使数值不变；
对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。
（2）方法
声明方法不能被子类重写。
（3）类
声明类不允许被继承。

2.static
（1）静态变量

（2）静态方法
静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。
只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。


（3）静态语句块
静态语句块在类初始化时运行一次。

（4）静态内部类
非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。

（5）静态导包
在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。

（6）初始化顺序
静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。
存在继承的情况下，初始化顺序为：
父类（静态变量、静态语句块）
子类（静态变量、静态语句块）
父类（实例变量、普通语句块）
父类（构造函数）
子类（实例变量、普通语句块）
子类（构造函数）


五。Object通用方法
(1)equals()
等价关系
1.自反性  2.对称性  3.传递性  4.一致性 5.与null比较

等价与相等
对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。
Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y)); // true
System.out.println(x == y);      // false


(2)hashcode()
hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。
等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。
在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。
HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。



(3)toString()
默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。


(4)clone()
不但要实现Cloneable接口，还要重写clone()方法

浅拷贝和深拷贝
浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象。
深拷贝：拷贝对象和原始对象的引用类型引用不同对象。

六。继承
（1）
访问权限：private、protected 以及 public 如果不加访问修饰符，表示包级可见。
类可见表示其它类可以用这个类创建实例对象。
成员可见表示其它类可以用这个类的实例对象访问到该成员；
protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。
访问权限应当尽可能地使每个类或者成员不被外界访问。

如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。
这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。

（2）抽象类与接口
抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。
抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。

接口是抽象类的延伸，也就是说它不能有任何的方法实现。
接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。


从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

使用接口：
需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；
需要使用多重继承。
使用抽象类：
需要在几个相关的类中共享代码。
需要能控制继承来的成员的访问权限，而不是都为 public。
需要继承非静态和非常量字段。
在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。

（3）Super
访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。
访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。


（4）重写和重载
（1。override
存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。
子类方法的访问权限必须大于等于父类方法；
子类方法的返回类型必须是父类方法返回类型或为其子类型。
子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。
在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有再到父类中查看，看是否从父类继承来。
否则就要对参数进行转型，转成父类之后看是否有对应的方法


（2。overload
存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。
返回值不同，其它都相同不算是重载。






七。反射
它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。
通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。
程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。
每个类都有一个 Class 对象，包含了与类有关的信息。
反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。
当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。
类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。


Java 反射主要提供以下功能：
在运行时判断任意一个对象所属的类；
在运行时构造任意一个类的对象；
在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
在运行时调用任意一个对象的方法

反射最重要的用途就是开发各种通用框架，运行时动态加载需要加载的对象。

反射的优点：
可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

反射的缺点：
性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。

安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。

内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

八。异常
Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。
受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。


九。泛型
泛型，即“参数化类型”。
就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），
然后在使用/调用时传入具体的类型（类型实参）。
Java中的泛型，只在编译阶段有效。泛型是通过类型擦除来实现的。
编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。
List<? extends T>可以接受任何继承自T的类型的List，而List<? super T>可以接受任何T的父类构成的List。
例如List<? extends Number>可以接受List<Integer>或List<Float>。


十。注解

Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

十一，特性
JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。
JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。


Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
Java 支持自动垃圾回收，而 C++ 需要手动回收。
Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。

泛型是如何工作的？
1、类型检查：在生成字节码之前提供类型检查
2、类型擦除：所有类型参数都用他们的限定类型替换，包括类、变量和方法（类型擦除）
3、如果类型擦除和多态性发生了冲突时，则在子类中生成桥方法解决
4、如果调用泛型方法的返回类型被擦除，则在调用该方法时插入强制类型转换
类型擦除：
所有类型参数都用他们的限定类型替换：
比如T->Object ? extends BaseClass->BaseClass
如何工作：
泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。
例如 List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。
你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。
根据你对这个泛型问题的回答情况，你会得到一些后续提问，比如为什么泛型是由类型擦除来实现的或者给你展示一些会导致编译器出错的错误泛型代码。
