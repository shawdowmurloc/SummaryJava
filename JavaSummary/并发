1.JMM了解吗
Java 线程的通信由 JMM 控制，JMM 的主要目的是定义程序中各种变量的访问规则。
JMM 遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。
编译器分析某个锁只会单线程访问就消除锁，某个 volatile 变量只会单线程访问就把它当作普通变量。
JMM 规定所有变量都存储在主内存，每条线程有自己的工作内存，工作内存中保存被该线程使用的变量的主内存副本，
线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。不同线程间无法直接访问对方工作内存中的变量，线程通信必须经过主内存。
JMM 定义了 8 种原子操作:
1.lock  主内存    把变量标识为线程独占状态
2.unlock 主内存  释放处于锁定状态的变量
3.read  主内存   把变量值从主内存传到工作内存
4.load 工作内存    	把 read 得到的值放入工作内存的变量副本
5.user  工作内存     	把工作内存中的变量值传给执行引擎
6.assign  工作内存  	把从执行引擎接收的值赋给工作内存变量
7.store  工作内存   把工作内存的变量值传到主内存
8.write 主内存   把 store 取到的变量值放入主内存变量中



2. as -if -serial是什么
不管怎么重排序，单线程程序的执行结果不能改变，编译器和处理器必须遵循 as-if-serial 语义。
为了遵循 as-if-serial，编译器和处理器不会对存在数据依赖关系的操作重排序，因为这种重排序会改变执行结果。
但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。


3.happen-before是什么
先行发生原则，JMM 定义的两项操作间的偏序关系，是判断数据是否存在竞争的重要手段。
程序次序规则：一个线程内写在前面的操作先行发生于后面的。
管程锁定规则： unlock 操作先行发生于后面对同一个锁的 lock 操作。
volatile 规则：对 volatile 变量的写操作先行发生于后面的读操作。
线程启动规则：线程的 start 方法先行发生于线程的每个动作。
线程终止规则：线程中所有操作先行发生于对线程的终止检测。JMM 通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新的方式实现可见性，
对象终结规则：对象的初始化先行发生于 finalize 方法。
传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C 。


4.as -if -serial和happen-before有什么区别
as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。
这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。


5.聊聊指令重排序？
为了提高性能，编译器和处理器通常会对指令进行重排序，重排序指从源代码到指令序列的重排序
1.编译器优化的重排序，编译器在不改变单线程程序语义的前提下可以重排语句的执行顺序。
2.指令级并行的重排序，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3.内存系统的重排序。


6.聊聊原子性、可见性、有序性
（1）原子性：
基本数据类型的访问都具备原子性，例外就是 long 和 double，虚拟机将没有被 volatile 修饰的 64 位数据操作划分为两次 32 位操作。

如果应用场景需要更大范围的原子性保证，JMM 还提供了 lock 和 unlock 操作满足需求，尽管 JVM 没有把这两种操作直接开放给用户使用，但是提供了更高层次的字节码指令 monitorenter 和 monitorexit，这两个字节码指令反映到 Java 代码中就是 synchronized。
（2）可见性：
可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。
JMM 通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新的方式实现可见性，

（3）有序性：
有序性可以总结为：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。
前半句指 as-if-serial 语义，后半句指指令重排序和工作内存与主内存延迟现象。


7.了解volatile吗？
当变量被定义为 volatile 后具备两种特性：
（1）保证变量对所有线程可见
当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。
（2）禁止指令重排序优化
使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相当于一个内存屏障，后面的指令不能重排到内存屏障之前。

